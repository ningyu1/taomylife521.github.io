#What?什么是java泛型#
泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。
泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型

泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。
这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。

通俗的讲，泛型就是操作类型的 占位符，即：假设占位符为T，那么此次声明的数据结构操作的数据类型为T类型。

#Why?为什么会出现java泛型#
1.当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。

2.因此，//1处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常

 类型安全：通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。没有泛型，这些假设就只存在于程序员的头脑中（或者如果幸运的话，还存在于代码注释中）。

消除强制类型转换

#how?怎么使用java泛型#
1. <？ extends E>：<? extends E> 是 Upper Bound（上限） 的通配符，用来限制元素的类型的上限，表示集合中的元素类型上限为E类型 或是 E的子类
2. <？ super E>：<? super E> 是 Lower Bound（下限） 的通配符 ，用来限制元素的类型下限。表示集合中元素类型下限为E类型。
3.  为什么要引入泛型通配符？一句话：为了保证类型安全。

#Where?什么场景下试用java泛型#

在泛型接口、泛型类和泛型方法的定义过程中，我们常见的如T、E、K、V等形式的参数常用于表示泛型形参，由于接收来自外部使用时候传入的类型实参.

如果要从集合中读取类型T的数据，并且不能写入，可以使用 ? extends 通配符；(Producer Extends)

如果要从集合中写入类型T的数据，并且不需要读取，可以使用 ? super 通配符；(Consumer Super)

如果既要存又要取，那么就不要使用任何通配符。